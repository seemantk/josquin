<!DOCTYPE html>
<head>
  <meta charset="utf-8">

  <!--
    This program loads note data for a single work in CSV format
    and renders it using D3.js.

    By Curran Kelleher <curran.kelleher@gmail.com>
      & Seemant Kulleen <seemantk@gmail.com>
    April 2016
  -->

  <!-- Bootstrap
    For reset and grid layout.
    from http://getbootstrap.com/customize/?id=c9c26f4080624c8af8ea9d80a6a64013
  -->
  <link rel="stylesheet" href="css/bootstrap.min.css">
  <style>
      rect, li {
          transition: opacity 0.5s ease;
      }
      rect.note {
          fill-opacity: 0.5;
      }
      .subdued {
          opacity: 0.1;
      }
      #legend li {
          cursor: pointer;
      }
      #legend li text {
          margin-left: 1em;
      }
      header {
          background-image: url('img/josquin.jpg');
          background-size: contain;
          background-repeat: no-repeat;
      }

      .brush .extent {
          stroke: black;
          fill-opacity: .08;
          stroke-opacity: .2;
          shape-rendering: crispEdges;
      }

      /* Tooltip styling inspired by http://bl.ocks.org/Caged/6476579 */
      .d3-tip {
          line-height: 1;
          padding: 5px;
          background: rgba(0, 0, 0, 0.5);
          color: #fff;
          border-radius: 2px;
      }

  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.6.7/d3-tip.min.js"></script>
</head>

<body>
  <header class="page-header text-center">
    <h1>Josquin Music Project</h1>
    <h2>Proof of Concept</h2>
  </header>
  <article>
    <div class="container">
      <div class="row">
        <div id="notes" class="col-xs-12 col-lg-10">
        </div>
        <div id="legend" class="col-xs-12 col-lg-2"></div>
      </div><!--.row-->
      <div class="row">
        <span>Note names: </span> <p id="note-names-string"></p>
        <span>Note durations: </span><p id="note-durations-string"></p>
      </div><!--.row-->
    </div><!--.container-->
  </article>
  <script>

    main();
    function main(){
        var notesViewContext = NotesView()
          , notesViewContextSVG = d3.select("#notes").append("svg")
          , notesViewFocus = NotesView()
          , notesViewFocusSVG = d3.select("#notes").append("svg")
          , colorLegend = ColorLegend()
          , jsonURL = "http://josquin.stanford.edu/cgi-bin/jrp?a=proll-json&f=Jos2721-La_Bernardina"
          , colorScale = d3.scale.category10()
          , notesViewFocus = NotesView()
        ;

        notesViewContext
            .colorScale(colorScale)
            .width(900)
            .height(150)
            .brushEnabled(true)
        ;

        notesViewFocus
            .colorScale(colorScale)
            .width(notesViewContext.width())
            .height(notesViewContext.height())
            .tipEnabled(true)
        ;

        colorLegend.colorScale(colorScale);

        function parseJSON(prollData){
          var data = [];
          prollData.partdata.forEach(function (part){
            var voice = prollData.partnames[part.partindex];
            part.notedata.forEach(function (note){
              data.push({
                pitch: note.pitch.b7,
                pitchName: note.pitch.name,
                time: note.starttime[0],
                duration: note.duration[0],
                voice: voice
              });
            });
          });
          return data;
        }

        d3.json(jsonURL, function (err, prollData){
            var data = parseJSON(prollData);
            chartify(data);

            // Test that the chartify function can be called multiple times with different data.
            //setTimeout(function(){
            //    var differentData = data
            //        .filter(function (d){
            //            // Remove some entries.
            //            return d.voice !== "Contra";
            //        })
            //        .map(function (d){
            //            return {
            //                pitch: d.pitch + Math.round(Math.random() * 5),
            //                time: d.time,
            //                duration: d.duration,
            //
            //                // Change a voice name.
            //                voice: d.voice === "Tenor" ? "Bassus" : d.voice
            //            };
            //        });
            //    chartify(differentData);
            //}, 500);

        });

        function type(d){
            d.pitch = +d.pitch;
            d.time = +d.time;
            d.duration = +d.duration;
            return d;
        }

        function chartify(data){

            colorScale.domain(data.map(function (d){
                return d.voice;
            }));

            renderNotesViewContext(data);
            renderNotesViewFocus(data);
            renderColorLegend(data);

            // When the user brushes in the context view,
            notesViewContext.onBrush(function (extent){

                // Filter the notes based on the selected time interval.
                var filteredData = data.filter(function (d){
                    return d.time > extent[0] && d.time < extent[1];
                });

                // Update the focus view.
                notesViewFocus.xDomain(extent);
                renderNotesViewFocus(filteredData);

                // Update the pitch names text.
                var pitchNames = filteredData.map(function (d){
                    return d.pitchName;
                }).join(", ");
                d3.select("#note-names-string").text(pitchNames);

                // Update the note names text.
                var pitchNames = filteredData.map(function (d){
                    return d.pitchName;
                }).join(", ");
                d3.select("#note-names-string").text(pitchNames);

                // Update the note durations text.
                var pitchNames = filteredData.map(function (d){
                    return d.duration;
                }).join(", ");
                d3.select("#note-durations-string").text(pitchNames);

                // TODO For the text entries, we may need to filter by the voice
                // that is currently selected from the legend. Currently, these
                // show notes from all voices combined, and not in temporal order.
            });
        }

        function renderNotesViewContext(data){
            notesViewContextSVG
                .datum(data)
                .call(notesViewContext)
            ;
        }

        function renderNotesViewFocus(data){
            notesViewFocusSVG
                .datum(data)
                .call(notesViewFocus)
            ;
        }

        function renderColorLegend(data){
            colorLegend
                .noteHeight(notesViewContext.noteHeight())
                .roundedCornerSize(notesViewContext.roundedCornerSize())
            ;
            colorLegend();
        }
    }

    function NotesView(){
        var width = 500
          , height = 500
          , x = d3.scale.linear()
          , y = d3.scale.linear()
          , brush = d3.svg.brush()
              .x(x)
              .on("brush", brushed)
          , brushEnabled = false
          , tipEnabled = false
          , onBrush
          , colorScale
          , noteHeight
          , roundedCornerSize

          // This is a fixed x domain set from outside,
          // it overrides the domain computed from the data.
          // This is set on the focus view based on the brush of the context view.
          , xDomain
          , tip = d3.tip()
              .attr("class", "d3-tip")
              .html(function(d) { return d.pitchName; });
        ;

        function brushed(){
            if(onBrush){
                onBrush(brush.empty() ? x.domain() : brush.extent());
            }
        }

        function my(selection){
            selection.each(function (data){

                var svg = d3.select(this)
                    .attr("height", height)
                    .attr("width", width)
                ;

                svg.selectAll("g")
                    .data(["notes-g", "brush"])
                    .enter()
                      .append("g")
                      .attr("class", function (d){ return d; });

                var notesG = svg.select(".notes-g")
                  , brushG = svg.select(".brush")
                ;

                if(xDomain){
                    x.domain(xDomain);
                } else {
                    x.domain([
                          d3.min(data, function(d) { return d.time; })
                        , d3.max(data, function(d) { return d.time + d.duration; })
                      ])
                    ;
                }
                y.domain([
                      d3.min(data, function(d) { return d.pitch - 1; })
                    , d3.max(data, function(d) { return d.pitch; })
                  ])
                ;
                x.range([0, width - 1]);
                y.range([height, 0]);

                noteHeight = height / (y.domain()[1] - y.domain()[0])
                roundedCornerSize = noteHeight / 2

                var rects = notesG.selectAll("rect").data(data);
                rects.enter().append("rect");
                rects.exit().remove();
                rects
                    .attr("x", function(d) { return x(d.time); })
                    .attr("y", function(d) { return y(d.pitch); })
                    .attr("width", function(d) { return x(d.time + d.duration) - x(d.time); })
                    .attr("height", noteHeight)
                    .attr("fill", function(d) { return colorScale(d.voice); })
                    .attr("stroke", function(d) { return colorScale(d.voice); })
                    .attr("rx", roundedCornerSize)
                    .attr("ry", roundedCornerSize)
                    .classed("note", true)
                ;

                if(brushEnabled){
                    brushG
                        .call(brush)
                      .selectAll("rect")
                        .attr("y", 0)
                        .attr("height", height - 1);
                }

                if(tipEnabled){
                    svg.call(tip);
                    rects
                        .on("mouseover", tip.show)
                        .on("mouseout", tip.hide)
                    ;
                }
            });
        } // my()

        my.colorScale = function (value){
            if(arguments.length === 0) return colorScale;
            colorScale = value;
            return my;
        };

        my.width = function (value){
            if(arguments.length === 0) return width;
            width = value;
            return my;
        };

        my.height = function (value){
            if(arguments.length === 0) return height;
            height = value;
            return my;
        };

        my.noteHeight = function (){ return noteHeight; };
        my.roundedCornerSize = function (){ return roundedCornerSize; };

        my.brushEnabled = function (value){
            if(arguments.length === 0) return brushEnabled;
            brushEnabled = value;
            return my;
        };

        my.onBrush = function (callback){
            onBrush = callback;
        };

        my.xDomain = function (value){
            xDomain = value;
        };

        my.tipEnabled = function (value){
            if(arguments.length === 0) return tipEnabled;
            tipEnabled = value;
            return my;
        };

        return my;
    }

    function ColorLegend(){
        var legend = d3.select("body #legend")
              .append("ul")
                .attr("class", "list-unstyled")
          , hilite
          , colorScale
          , noteHeight
          , roundedCornerSize
        ;

        function my(options) {
            var svg = d3.select("#notes").selectAll("svg")
              , row = legend.selectAll("li")
                    .data(colorScale.domain())
            ;
            legend
                .on("click", function() {
                    hilite = false;
                    svg.selectAll("rect")
                        .classed("subdued", false)
                    ;
                  })
            ;
            row.enter()
              .append("li")
                .each(function(c) {
                    var self = d3.select(this);
                    self
                      .append("svg")
                        .attr("x", 0)
                        .attr("y", noteHeight)
                        .attr("width", 22)
                        .attr("height", noteHeight)
                      .append("rect")
                        .attr("class", c.toLowerCase())
                        .classed("note", true)
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", "100%")
                        .attr("height", "100%")
                        .attr("fill", colorScale(c))
                        .attr("stroke", colorScale(c))
                        .attr("rx", roundedCornerSize)
                        .attr("ry", roundedCornerSize)
                    ;
                    self
                      .append("text")
                        .text(c)
                    ;
                  })
            ;
            row
              .on("click", function(c) {
                  d3.event.stopPropagation();
                  hilite = hilite === c ? false : c;
                  svg.selectAll("rect.note")
                      .classed("subdued", function(d) {
                          return hilite && d.voice !== c;
                        })
                  ;
                  legend.selectAll("li")
                      .classed("subdued", function(d) {
                          return hilite && d !== c;
                        })
                  ;
                })
            ;
            row.exit().remove();
        } // my()

        my.colorScale = function (value){
            if(arguments.length === 0){
                return colorScale;
            }
            colorScale = value;
        };

        my.height = function (value){
            if(arguments.length === 0) return height;
            height = value;
            return my;
        };

        my.noteHeight = function (value){
            if(arguments.length === 0) return noteHeight;
            noteHeight = value;
            return my;
        };

        my.roundedCornerSize = function (value){
            if(arguments.length === 0) return roundedCornerSize;
            roundedCornerSize = value;
            return my;
        };

        return my;
    }
  </script>
</body>
